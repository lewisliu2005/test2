# 41243221

# 41243250

### 組員名單

- 林榆傑 41243221
- 劉宗修 41243250

# K-way 外部排序

## 解題說明

本題背景為在記憶體容量有限（\( S \ll n \)）的情況下，針對大於記憶體的資料量進行外部排序，參考課本中的 Buffering (Program 7.21) 方法。

### 解題策略

本題分為兩個部分：

(a) 推導輸入時間公式：計算外部排序第二階段（\( k \)-way merge）的總輸入時間，涉及以下時間因素：
   1. 尋道時間 \( t_s \)
   2. 延遲時間 \( t_l \)
   3. 每筆資料的傳輸時間 \( t_t \)

(b) 數值分析和圖表繪製：根據給定參數，繪製總輸入時間 \( t_{input} \) 隨 \( k \)（每輪合併的 run 數）變化的圖形，並探討是否存在某個 \( k \) 值，使 \( t_{input} \approx t_{CPU} \)（輸入時間與 CPU 處理時間相近）。

### 符號定義

| 參數      | 解釋                          | 數值 (若適用)    |
| --------- | ----------------------------- | ---------------- |
| \( n \)   | 資料總筆數                    | 200,000          |
| \( m \)   | 初始 run 數量                 | 64               |
| \( S \)   | 記憶體容量                    | 2,000            |
| \( t_s \) | 磁碟 seek time（尋道時間）    | 80 ms = 0.08 sec |
| \( t_l \) | 磁碟 latency time（延遲時間） | 20 ms = 0.02 sec |
| \( t_t \) | 傳送每筆資料的時間            | 0.001 sec        |
| \( t_{CPU} \) | CPU 合併所有 run 所花的總時間 | (未指定，常數)   |
| \( k \)   | 每輪合併的 run 數             | (變數)           |

## 程式實作

> [!NOTE]
> 由於本題為純粹計算題，本節將作為解題實作說明。

### 第一小題 (a)

#### 解題過程
題目要求推導第 2 階段（合併階段）的總輸入時間 \( t_{input} \)。根據 \( k \)-way merge 的外部排序特性：

- **時間組成**：
  - \( t_s \) 和 \( t_l \) 為每次磁盤訪問的尋道和延遲開銷。
  - \( t_t \) 為每筆資料的傳輸時間，與總資料量 \( n \) 成正比。
  - 內存容量 \( S \) 分為 \( k+1 \) 個緩衝區（\( k \) 個輸入，1 個輸出），允許輸入/輸出與 CPU 並行。

- **合併過程**：
  - 初始有 \( m \) 個 run，需進行 \( \lceil \log_k m \rceil \) 輪合併。
  - 每輪合併從 \( k \) 個 run 讀取資料，總共處理 \( n \) 條記錄。
  - 磁盤訪問次數近似為 \( k \cdot \log_k m \)（每輪 \( k \) 次訪問，輪數為 \( \log_k m \)）。

- **公式推導**：
  - 總磁盤訪問時間：\( (k \cdot \log_k m) \cdot (t_s + t_l) \)。
  - 總傳輸時間：\( n \cdot t_t \)。
  - 考慮並行，輸入時間為兩者之和（傳輸時間可能部分重疊，但為保守估計加總）。

因此，總輸入時間公式為：
\[
t_{input} = (k \cdot \log_k m) \cdot (t_s + t_l) + (n \cdot t_t)
\]
其中 \( \log_k m = \frac{\log m}{\log k} \)。

#### 驗證
以 \( k = 4 \)，\( m = 64 \)：
- \( \log_4 64 = \frac{\log_2 64}{\log_2 4} = \frac{6}{2} = 3 \)
- 訪問次數 \( 4 \cdot 3 = 12 \)
- \( t_s + t_l = 0.08 + 0.02 = 0.1 \, \text{sec} \)
- 傳輸時間 \( n \cdot t_t = 200,000 \cdot 0.001 = 200 \, \text{sec} \)
- \( t_{input} = 12 \cdot 0.1 + 200 = 201.2 \, \text{sec} \)（與後續計算一致）。

### 第二小題 (b)

#### 數值計算
將給定參數帶入公式，計算 \( t_{input} \) 隨 \( k \) 變化：

| \( k \)  | \( \log_k 

 64 \) | 磁盤訪問次數 (\( k \cdot \log_k 64 \)) | \( t_{input} = (k \cdot \log_k 64) \cdot 0.1 + 200 \) (秒) |
|----------|-----------------|---------------------------------------|---------------------------------------------------------|
| 0        | -               | -                                     | 200                                                     |
| 100      | 0.322           | 32.2                                   | 203.22                                                  |
| 200      | 0.215           | 43.0                                   | 204.30                                                  |
| 300      | 0.165           | 49.5                                   | 204.95                                                  |
| 400      | 0.135           | 54.0                                   | 205.40                                                  |
| 500      | 0.115           | 57.5                                   | 205.75                                                  |
| 600      | 0.101           | 60.6                                   | 206.06                                                  |

- \( \log_k 64 = \frac{\log 64}{\log k} = \frac{1.806}{\log_{10} k} \)（以 10 為底近似計算）。
- 當 \( k \) 過大時，\( \log_k m \) 趨近 0，訪問次數增長緩慢。

#### 圖表繪製
以下為 \( t_{input} \) 隨 \( k \) 變化的線圖：

```chartjs
{
  "type": "line",
  "data": {
    "labels": [0, 100, 200, 300, 400, 500, 600],
    "datasets": [{
      "label": "Total Input Time (seconds)",
      "data": [200, 203.22, 204.30, 204.95, 205.40, 205.75, 206.06],
      "borderColor": "#36A2EB",
      "backgroundColor": "#36A2EB",
      "fill": false,
      "pointRadius": 5
    }]
  },
  "options": {
    "scales": {
      "x": {
        "title": {
          "display": true,
          "text": "k (Merge Ways)"
        }
      },
      "y": {
        "title": {
          "display": true,
          "text": "Time (seconds)"
        },
        "beginAtZero": true
      }
    }
  }
}
```

#### 分析
1. **趨勢**：\( t_{input} \) 隨 \( k \) 增加略升，初始值約 200 秒（傳輸主導），後因 \( k \cdot \log_k m \) 增長而緩慢上升。
2. **\( t_{input} \approx t_{CPU} \)**：\( t_{CPU} \) 為常數，問題未指定值。假設 \( t_{CPU} \) 在 200-206 秒範圍內，存在 \( k \)（如 0-100）使 \( t_{input} \approx t_{CPU} \)。若 \( t_{CPU} \) 遠離此範圍，則無解。
3. **結論**：不總是存在 \( k \) 使 \( t_{input} \approx t_{CPU} \)，取決於 \( t_{CPU} \) 的具體值。

## 效能分析

- **公式影響**：
  - \( t_{input} = (k \cdot \log_k m) \cdot (t_s + t_l) + (n \cdot t_t) \)
  - 增加 \( S \) 可減少磁盤訪問次數（若考慮緩衝影響），降低 IO 時間。
  - 合併輪數 \( O(\log_k m) \)，時間複雜度為 \( O(\log_k m) \)。

## 測試與驗證

- 驗證 \( \log_k m \)：
  - \( \log_2 4 = 2 \)
  - \(之旅 \log_4 16 = 2 \)
  - \( \log_4 64 = 3 \)（與輪數一致）。

### 結論
\( \log_k m \) 準確反映合併輪數。

## 申論及開發報告

- **優點**：\( k \)-way merge 有效降低排序成本，適合大數據排序。
- **\( k \) 選擇**：需平衡合併效率與記憶體使用，過大 \( k \) 可能增加管理複雜度。

### 心得


41243243
41243244
組員名單

黃安可 41243243
黃順駿 41243244

第三題報告
K-way 外部排序
解題說明
本題背景為在記憶體容量有限，排序資料量大於記憶體的情況下 (( S \ll n ))，使用課本 (程式 7-21) 進行外部排序。
解題策略
本題分為兩個部分：
(a)、 推導輸入時間公式：需計算外部排序第二階段（( k )-way merge）的總輸入時間，時間因素包括：

尋道時間 ( t_s )

延遲時間 ( t_l )

每筆資料的傳輸時間 ( t_t )


(b)、 數值分析和圖表繪製：在給定相關參數下，繪製總輸入時間 ( t_{input} ) 隨 ( k )(每輪合併的 run 數) 變化的圖形，並觀察是否存在某個 ( k ) 值，使得 ( t_{input} \approx t_{CPU} )，輸入所需時間與 CPU 處理時間相近。
符號定義



參數
解釋



( n )
資料總筆數


( m )
初始 run 數量


( S )
記憶體容量


( t_s )
磁碟 seek time（尋道時間）


( t_l )
磁碟 latency time（延遲）


( t_t )
傳送每筆資料的時間


( t_{CPU} )
CPU 合併所有 run 所花的總時間


( k )
每輪合併的 run 數


程式實作

[!NOTE]由於本題為純粹計算題，因此本小節將作為解題實作

第一小題 (a)
題目要求推導總輸入時間，根據題意輸入時間包含以下：

( t_s ) 搜尋時間
( t_l ) 延遲時間
( t_t ) 傳輸每筆資料的時間

其中 ( t_s ) 和 ( t_l ) 為磁碟方面花費的時間，因此為每次讀取資料需要的開銷，而 ( t_t ) 則與資料筆數成正比，僅在資料實際傳輸過程中產生。

推導過程：
外部排序的第 2 階段為合併階段，初始有 ( m ) 個 run，使用 ( k )-way merge，需進行 ( \log_k m ) 輪合併（向上取整）。
每輪合併從 ( k ) 個 run 讀取資料，總共處理 ( n ) 條記錄，磁盤訪問次數近似為 ( k \cdot \log_k m )。
每次磁盤訪問的開銷為 ( t_s + t_l )，總傳輸時間為 ( n \cdot t_t )。
考慮並行，輸入時間為磁盤訪問時間與傳輸時間之和。



因此，總輸入時間公式為：[t_{input} = (k \cdot \log_k m) \cdot (t_s + t_l) + (n \cdot t_t)]其中 ( \log_k m = \frac{\log m}{\log k} )。

第二小題 (b)
題目給定了參數值，我們將題目的參數值帶入，整理成以下表格：



參數
解釋
數值



( n )
資料總筆數
200,000


( m )
初始 run 數量
64


( S )
記憶體容量
2,000


( t_s )
磁碟 seek time（尋道時間）
80 ms = 0.08 sec


( t_l )
磁碟 latency time（延遲）
20 ms = 0.02 sec


( t_t )
傳送每筆資料的時間
0.001 sec


( t_{CPU} )
CPU 合併所有 run 所花的總時間
(未指定)


( k )
每輪合併的 run 數
(變數)


將上述參數值帶入第一小題整理出的公式，計算 ( t_{input} )：
[t_{input} = (k \cdot \log_k 64) \cdot (0.08 + 0.02) + (200,000 \cdot 0.001)][t_{input} = (k \cdot \log_k 64) \cdot 0.1 + 200]
計算不同 ( k ) 值（0, 100, 200, 300, 400, 500, 600）下的 ( t_{input} )：

( \log_k 64 = \frac{\log 64}{\log k} = \frac{1.806}{\log_{10} k} )（以 10 為底）。
當 ( k = 0 )，假設 ( \log_k 64 ) 無意義，僅計算傳輸時間。




( k )
( \log_k 64 )
磁盤訪問次數 (( k \cdot \log_k 64 ))
( t_{input} ) (秒)



0
-
0
200


100
0.322
32.2
203.22


200
0.215
43.0
204.30


300
0.165
49.5
204.95


400
0.135
54.0
205.40


500
0.115
57.5
205.75


600
0.101
60.6
206.06


繪製 ( t_{input} ) 隨 ( k ) 變化的圖形：
{
  "type": "line",
  "data": {
    "labels": [0, 100, 200, 300, 400, 500, 600],
    "datasets": [{
      "label": "Total Input Time (seconds)",
      "data": [200, 203.22, 204.30, 204.95, 205.40, 205.75, 206.06],
      "borderColor": "#36A2EB",
      "backgroundColor": "#36A2EB",
      "fill": false,
      "pointRadius": 5
    }]
  },
  "options": {
    "scales": {
      "x": {
        "title": {
          "display": true,
          "text": "k (Merge Ways)"
        }
      },
      "y": {
        "title": {
          "display": true,
          "text": "Time (seconds)"
        },
        "beginAtZero": true
      }
    }
  }
}

上圖為「輸入時間 ( t_{input} ) 隨 ( k )(每輪合併的 run 數) 變化」的關係圖。可以觀察到以下幾點：

整體趨勢為遞增：
隨著 ( k ) 值增加，磁盤訪問次數 ( k \cdot \log_k m ) 增加，導致整體輸入時間緩慢上升，但因 ( \log_k m ) 隨 ( k ) 減小，增長幅度有限。

增長幅度隨 ( k ) 變大而趨緩：
當 ( k ) 從小值（如 100）增加時，( t_{input} ) 緩慢上升，但當 ( k ) 超過 300 後，增長趨於平緩，因為 ( \log_k 64 ) 減小，總訪問次數增長減緩。

選擇 ( k ) 時的取捨考量：
雖然 ( k ) 越大合併輪數越少，但磁盤訪問次數隨 ( k ) 增加，需平衡 ( k ) 值與記憶體分配（( k+1 \leq S )），選擇適當 ( k ) 以優化總時間。


( t_{input} \approx t_{CPU} ) ?
本題假設 ( t_{CPU} ) 為一個常數，並未給定明確數值，( t_{CPU} ) 表示 CPU 合併所有 run 所花的總時間，而 ( t_{input} ) 表示處理輸入資料所花費的時間。
( t_{input} ) 隨 ( k ) 遞增，( t_{CPU} ) 保持不變，因此在某個 ( k ) 值附近 ( t_{input} ) 可能會接近 ( t_{CPU} )。從圖表看，( t_{input} ) 範圍為 200 至 206.06 秒，若 ( t_{CPU} ) 在此範圍內，則存在 ( k ) 值使 ( t_{input} \approx t_{CPU} )。若 ( t_{CPU} ) 遠離此範圍，則無解。因此答案是不確定，但有機會發生 ( t_{input} \approx t_{CPU} ) 的情況。
效能分析

( t_{input} = (k \cdot \log_k m) \cdot (t_s + t_l) + (n \cdot t_t) )


由此可知當 ( S ) 記憶體容量增加，可減少 IO 輸入的時間（若考慮緩衝區大小 ( \frac{S}{k+1} )），因為能一次讀取更多資料，減少磁盤訪問次數。但需視實際情況平衡經濟考量與系統資源。

merge 的次數
需要執行 ( O(\log_k m) ) 次


時間複雜度：( O(\log_k m) ) (Merge)
測試與驗證

驗證 ( \log_k m ) == 執行 RUN 數

( \log_2 4 )
( \log_2 4 = 2 )（需 2 輪合併）
( \log_4 4 )
( \log_4 4 = 1 )（需 1 輪合併）
( \log_4 11 )
( \log_4 11 \approx 1.73 )，向上取整為 2（需 2 輪合併）
結論
得證 ( \log_k m ) == 執行 RUN 數。
申論及開發報告

使用外部排序中的 ( k )-way 合併能有效降低排序成本。
選擇適當的 ( k ) 值需平衡合併效率與程式實作負擔。

心得
黃安可心得
這是一個純手寫的題目，沒有用到實作的部分，但要理解課本的題目真的花了我們好一段時間才明白，外部排序或許在我們看來就是一個根本不會使用到的技術，但懂了他之後在排序的能力上肯定會更厲害，計算題目的時候會一直懷疑自己到底是不是對的，會寫到懷疑人生，然後還要想要怎麼寫成報告，但是最後我們都完成了，也完成了三個資結作業，總之好玩!!
黃順駿心得
這次報告讓我首次從效能分析的角度深入了解排序演算法，特別是 ( k )-way 合併在外部排序中的重要性。透過公式推導與圖表分析，我學會將演算法轉化為可量化的模型，並理解記憶體與磁碟存取效率對系統效能的影響，對未來處理大量資料非常有幫助。

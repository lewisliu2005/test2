# 41243243

# 41243244

### 組員名單

* 黃安可 41243243
* 黃順駿 41243244

# K-way 外部排序

## 解題說明

本題背景為在記憶體容量有限 (S << n) 的情況下，針對大於記憶體的資料量進行外部排序，參考課本中的 Buffering (Program 7.21) 方法。

### 解題策略

本題分為兩個部分：

(a) 推導輸入時間公式：計算外部排序第二階段（ k-way merge）的總輸入時間，涉及以下時間因素：

1. 尋道時間 \$t\_s\$
2. 延遲時間 \$t\_l\$
3. 每筆資料的傳輸時間 \$t\_t\$

(b) 數值分析和圖表繪製：根據給定參數，繪製總輸入時間 \$t\_{input}\$ 隨 \$k\$（每輪合併的 run 數）變化的圖形，並探討是否存在某個 \$k\$ 值，使 \$t\_{input} \approx t\_{CPU}\$（輸入時間與 CPU 處理時間相近）。

### 符號定義

| 參數           | 解釋                    | 數值 (若適用)         |
| ------------ | --------------------- | ---------------- |
| \$n\$        | 資料總筆數                 | 200,000          |
| \$m\$        | 初始 run 數量             | 64               |
| \$S\$        | 記憶體容量                 | 2,000            |
| \$t\_s\$     | 磁碟 seek time（尋道時間）    | 80 ms = 0.08 sec |
| \$t\_l\$     | 磁碟 latency time（延遲時間） | 20 ms = 0.02 sec |
| \$t\_t\$     | 傳送每筆資料的時間             | 0.001 sec        |
| \$t\_{CPU}\$ | CPU 合併所有 run 所花的總時間   | (未指定，常數)         |
| \$k\$        | 每輪合併的 run 數           | (變數)             |

## 程式實作

> \[!NOTE]
> 由於本題為純粹計算題，本節將作為解題實作說明。

### 第一小題 (a)

#### 解題過程

題目要求推導第 2 階段（合併階段）的總輸入時間 \$t\_{input}\$。根據 \$k\$-way merge 的外部排序特性：

* **時間組成**：

  * \$t\_s\$ 和 \$t\_l\$ 為每次磁盤訪問的尋道和延遲開銷。
  * \$t\_t\$ 為每筆資料的傳輸時間，與總資料量 \$n\$ 成正比。
  * 內存容量 \$S\$ 分為 \$k+1\$ 個緩衝區（ k 個輸入，1 個輸出），允許輸入/輸出與 CPU 並行。

* **合併過程**：

  * 初始有 \$m\$ 個 run，需進行 \$\lceil \log\_k m \rceil\$ 輪合併。
  * 每輪合併從 \$k\$ 個 run 讀取資料，總共處理 \$n\$ 條記錄。
  * 磁盤訪問次數近似為 \$k \cdot \log\_k m\$（每輪 \$k\$ 次訪問，輪數為 \$\log\_k m\$）。

* **公式推導**：

  * 總磁盤訪問時間: \$(k \cdot \log\_k m) \cdot (t\_s + t\_l) \$
  * 總傳輸時間： \$n \cdot t\_t\$
  * 考慮並行，輸入時間為兩者之和（傳輸時間可能部分重疊，但為保守估計加總）
  
因此，總輸入時間公式為：

### \$t\_{input} = (k \cdot \log\_k m) \cdot (t\_s + t\_l) + n \cdot t\_t\$

其中 \$\log\_k m = \frac{\log m}{\log k}\$。

#### 驗證

以 \$k = 4\$，\$m = 64\$：

* \$\log\_4 64 = \frac{\log\_2 64}{\log\_2 4} = \frac{6}{2} = 3\$
* 訪問次數 \$4 \cdot 3 = 12\$
* \$t\_s + t\_l = 0.08 + 0.02 = 0.1\$ sec
* 傳輸時間 \$n \cdot t\_t = 200,000 \cdot 0.001 = 200\$ sec
* \$t\_{input} = 12 \cdot 0.1 + 200 = 201.2\$ sec（與後續計算一致）

### 第二小題 (b)

#### 數值計算

將給定參數帶入公式，計算 \$t\_{input}\$ 隨 \$k\$ 變化：

| \$k\$ | \$\log\_k 64\$ | 磁盤訪問次數 (\$k \cdot \log\_k 64\$) | \$t\_{input} = (k \cdot \log\_k 64) \cdot 0.1 + 200\$ (秒) |
| ----- | -------------- | ------------------------------- | --------------------------------------------------------- |
| 0     | -              | -                               | -                                                         |
| 100   | 0.322          | 32.2                            | 203.22                                                    |
| 200   | 0.215          | 43.0                            | 204.30                                                    |
| 300   | 0.165          | 49.5                            | 204.95                                                    |
| 400   | 0.135          | 54.0                            | 205.40                                                    |
| 500   | 0.115          | 57.5                            | 205.75                                                    |
| 600   | 0.101          | 60.6                            | 206.06                                                    |

* \$\log\_k 64 = \frac{\log 64}{\log k} = \frac{1.806}{\log\_{10} k}\$（以 10 為底近似）

#### 圖表繪製

```chartjs
{
  "type": "line",
  "data": {
    "labels": [0, 100, 200, 300, 400, 500, 600],
    "datasets": [{
      "label": "Total Input Time (seconds)",
      "data": [200, 203.22, 204.30, 204.95, 205.40, 205.75, 206.06],
      "borderColor": "#36A2EB",
      "backgroundColor": "#36A2EB",
      "fill": false,
      "pointRadius": 5
    }]
  },
  "options": {
    "scales": {
      "x": {
        "title": {
          "display": true,
          "text": "k (Merge Ways)"
        }
      },
      "y": {
        "title": {
          "display": true,
          "text": "Time (seconds)"
        },
        "beginAtZero": true
      }
    }
  }
}
```

#### 分析

1. **趨勢**：\$t\_{input}\$ 隨 \$k\$ 增加略升，初始值約 200 秒（傳輸主導），後因 \$k \cdot \log\_k m\$ 增長而緩慢上升。
2. **\$t\_{input} \approx t\_{CPU}\$**：\$t\_{CPU}\$ 為常數，問題未指定值。假設 \$t\_{CPU}\$ 在 200–206 秒範圍內，存在 \$k\$（如 0–100）使 \$t\_{input} \approx t\_{CPU}\$。若 \$t\_{CPU}\$ 遠離此範圍，則無解。
3. **結論**：不總是存在 \$k\$ 使 \$t\_{input} \approx t\_{CPU}\$，取決於 \$t\_{CPU}\$ 的具體值。

## 效能分析

* **公式影響**：

  * \$t\_{input} = (k \cdot \log\_k m) \cdot (t\_s + t\_l) + (n \cdot t\_t)\$
  * 增加 \$S\$ 可減少 \$\frac{n}{S}\$ 項（若考慮緩衝影響），降低 IO 時間
  * 合併輪數為 \$O(\log\_k m)\$，時間複雜度為 \$O(\log\_k m)\$

## 測試與驗證

* 驗證 \$\log\_k m\$：

  * \$\log\_2 4 = 2\$
  * \$\log\_4 16 = 2\$
  * \$\log\_4 64 = 3\$（與輪數一致）

### 結論

\$\log\_k m\$ 準確反映合併輪數。

## 申論及開發報告

* **優點**： k-way merge 有效降低排序成本，適合大數據排序。
* **\$k\$ 選擇**：需平衡合併效率與記憶體使用，過大 \$k\$ 可能增加管理複雜度。

### 心得

#### 黃安可心得

這題純靠手算，理解外部排序花了很多時間。雖然看似不常用，但掌握後對排序能力提升很大。計算時常懷疑自己，最後完成三個作業，過程雖辛苦但有趣！

#### 黃順駿心得

透過這次報告，我從效能角度深入了解 \$k\$-way merge，在公式與圖表中學習將理論轉化為模型，認識記憶體與磁碟效率對大數據處理的影響，未來很有幫助。

---

如果需要轉成 PDF、加上封面、或者改成報告用 word 格式，我也可以幫你整理！
